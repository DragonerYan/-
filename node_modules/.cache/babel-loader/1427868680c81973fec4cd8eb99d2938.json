{"remainingRequest":"D:\\github007\\vue2-element-touzi-admin\\node_modules\\babel-loader\\lib\\index.js!D:\\github007\\vue2-element-touzi-admin\\src\\permission.js","dependencies":[{"path":"D:\\github007\\vue2-element-touzi-admin\\src\\permission.js","mtime":1604132537175},{"path":"D:\\github007\\vue2-element-touzi-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\github007\\vue2-element-touzi-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"D:\\\\github007\\\\vue2-element-touzi-admin\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport router from \"./router\";\nimport store from \"./store\";\nimport NProgress from 'nprogress'; // Progress 进度条\n\nprocess.env.NODE_ENV === \"development\" && import('nprogress/nprogress.css');\nimport { Message } from 'element-ui';\nimport { getToken } from '@/utils/auth'; // 验权(从cookie中获取)\n\nimport { getUserInfo } from \"@/api/user\";\nimport { setTitle } from '@/utils/mUtils'; // 设置浏览器头部标题\n\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true;\n  if (!permissionRoles) return true;\n  return roles.some(function (role) {\n    return permissionRoles.indexOf(role) >= 0;\n  });\n}\n\nvar whiteList = ['/login']; // 不重定向白名单\n\nrouter.beforeEach(function (to, from, next) {\n  NProgress.start(); // 设置浏览器头部标题\n\n  var browserHeaderTitle = to.meta.title;\n  store.commit('SET_BROWSERHEADERTITLE', {\n    browserHeaderTitle: browserHeaderTitle\n  }); // 点击登录时，拿到了token并存入了cookie,保证页面刷新时,始终可以拿到token\n\n  if (getToken('Token')) {\n    if (to.path === '/login') {\n      next({\n        path: '/'\n      });\n      NProgress.done();\n    } else {\n      // 用户登录成功之后，每次点击路由都进行了角色的判断;\n      if (store.getters.roles.length === 0) {\n        var token = getToken('Token');\n        getUserInfo({\n          \"token\": token\n        }).then().then(function (res) {\n          // 根据token拉取用户信息\n          var userList = res.data.userList;\n          store.commit(\"SET_ROLES\", userList.roles);\n          store.commit(\"SET_NAME\", userList.name);\n          store.commit(\"SET_AVATAR\", userList.avatar);\n          store.dispatch('GenerateRoutes', {\n            \"roles\": userList.roles\n          }).then(function () {\n            // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters); // 动态添加可访问权限路由表\n\n            next(_objectSpread({}, to, {\n              replace: true\n            })); // hack方法 确保addRoutes已完成\n          });\n        }).catch(function (err) {\n          store.dispatch('LogOut').then(function () {\n            Message.error(err || 'Verification failed, please login again');\n            next({\n              path: '/'\n            });\n          });\n        });\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next(); //\n        } else {\n          next({\n            path: '/401',\n            replace: true,\n            query: {\n              noGoBack: true\n            }\n          });\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) {\n      // 点击退出时,会定位到这里\n      next();\n    } else {\n      next('/login');\n      NProgress.done();\n    }\n  }\n});\nrouter.afterEach(function () {\n  NProgress.done(); // 结束Progress\n\n  setTimeout(function () {\n    var browserHeaderTitle = store.getters.browserHeaderTitle;\n    setTitle(browserHeaderTitle);\n  }, 0);\n});\n/**\r\n  本系统权限逻辑分析：\r\n  1、路由对象区分权限路由对象和非权限路由对象；初始化时，将非权限路由对象赋值给Router;同时设置权限路由中的meta对象，如:meta:{roles:['admin','editor']}\r\n     表示该roles所拥有的路由权限;\r\n  2、通过用户登录成功之后返回的roles值，进行路由的匹配并生成新的路由对象;\r\n  3、用户成功登录并跳转到首页时，根据刚刚生成的路由对象，渲染左侧的菜单;即，不同的用户看到的菜单是不一样的;\r\n  \r\n  用户点击登录和退出之后的业务逻辑分析：\r\n  1、用户点击登录按钮，通过路由导航钩子router.beforeEach()函数确定下一步的跳转逻辑,如下：\r\n   1.1、用户已经登录成功过，并从cookie中拿到了token值;\r\n     1.1.1、用户访问登录页面,直接定位到登录页面;\r\n     1.1.1、用户访问非登录页面,需要根据用户是否有roles信息，进行不同的业务逻辑,如下：\r\n        (1)、初始情况下,用户roles信息为空;\r\n            1.通过getUserInfo()函数,根据token拉取用户信息;并通过store将该用户roles,name,avatar信息存储于vuex;\r\n            2.通过store.dispatch('GenerateRoutes', { roles })去重新过滤和生成路由,通过router.addRoutes()合并路由表;   \r\n            3.如果在获取用户信息接口时出现错误，则调取store.dispatch('LogOut')接口,返回到login页面;\r\n          \r\n        (2)、用户已经拥有roles信息；\r\n            1.点击页面路由，通过roles权限判断 hasPermission()。如果用户有该路由权限，直接跳转对应的页面;如果没有权限，则跳转至401提示页面;\r\n  \r\n  2.用户点击退出,token已被清空\r\n    1.如果设置了白名单用户，则直接跳转到相应的页面;\r\n    2.反之,则跳转至登录页面;\r\n */",{"version":3,"sources":["D:\\github007\\vue2-element-touzi-admin\\src\\permission.js"],"names":["router","store","NProgress","process","env","NODE_ENV","Message","getToken","getUserInfo","setTitle","hasPermission","roles","permissionRoles","indexOf","some","role","whiteList","beforeEach","to","from","next","start","browserHeaderTitle","meta","title","commit","path","done","getters","length","token","then","res","userList","data","name","avatar","dispatch","addRoutes","addRouters","replace","catch","err","error","query","noGoBack","afterEach","setTimeout"],"mappings":"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","sourcesContent":["import router from './router'\r\nimport store from './store'\r\nimport NProgress from 'nprogress' // Progress 进度条\r\nprocess.env.NODE_ENV === \"development\" && import('nprogress/nprogress.css')\r\nimport { Message } from 'element-ui'\r\nimport { getToken } from '@/utils/auth' // 验权(从cookie中获取)\r\nimport { getUserInfo } from \"@/api/user\";\r\nimport {\r\n  setTitle\r\n} from '@/utils/mUtils' // 设置浏览器头部标题\r\n\r\nfunction hasPermission(roles, permissionRoles) {\r\n  if (roles.indexOf('admin') >= 0) return true \r\n  if (!permissionRoles) return true\r\n  return roles.some(role => permissionRoles.indexOf(role) >= 0)\r\n}\r\nconst whiteList = ['/login'] // 不重定向白名单\r\n\r\nrouter.beforeEach((to, from, next) => {\r\n  NProgress.start()\r\n   // 设置浏览器头部标题\r\n   const browserHeaderTitle = to.meta.title\r\n   store.commit('SET_BROWSERHEADERTITLE', {\r\n     browserHeaderTitle: browserHeaderTitle\r\n   })\r\n  // 点击登录时，拿到了token并存入了cookie,保证页面刷新时,始终可以拿到token\r\n  if (getToken('Token')) {\r\n    if(to.path === '/login') {\r\n      next({ path: '/' })  \r\n      NProgress.done() \r\n    } else {\r\n      // 用户登录成功之后，每次点击路由都进行了角色的判断;\r\n      if (store.getters.roles.length === 0) {\r\n        let token = getToken('Token');\r\n        getUserInfo({\"token\":token}).then().then(res => { // 根据token拉取用户信息\r\n          let userList = res.data.userList;\r\n          store.commit(\"SET_ROLES\",userList.roles);\r\n          store.commit(\"SET_NAME\",userList.name);\r\n          store.commit(\"SET_AVATAR\",userList.avatar);\r\n          store.dispatch('GenerateRoutes', { \"roles\":userList.roles }).then(() => { // 根据roles权限生成可访问的路由表\r\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问权限路由表\r\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成\r\n          })\r\n        }).catch((err) => {\r\n          store.dispatch('LogOut').then(() => {\r\n            Message.error(err || 'Verification failed, please login again')\r\n            next({ path: '/' })\r\n          })\r\n        })\r\n      } else {\r\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\r\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\r\n          next()//\r\n        } else {\r\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    if (whiteList.indexOf(to.path) !== -1) {\r\n      // 点击退出时,会定位到这里\r\n      next()\r\n    } else {\r\n      next('/login')\r\n      NProgress.done()\r\n    }\r\n  }\r\n})\r\n\r\nrouter.afterEach(() => {\r\n  NProgress.done() // 结束Progress\r\n  setTimeout(() => {\r\n    const browserHeaderTitle = store.getters.browserHeaderTitle\r\n    setTitle(browserHeaderTitle)\r\n  }, 0)\r\n})\r\n\r\n\r\n\r\n/**\r\n  本系统权限逻辑分析：\r\n  1、路由对象区分权限路由对象和非权限路由对象；初始化时，将非权限路由对象赋值给Router;同时设置权限路由中的meta对象，如:meta:{roles:['admin','editor']}\r\n     表示该roles所拥有的路由权限;\r\n  2、通过用户登录成功之后返回的roles值，进行路由的匹配并生成新的路由对象;\r\n  3、用户成功登录并跳转到首页时，根据刚刚生成的路由对象，渲染左侧的菜单;即，不同的用户看到的菜单是不一样的;\r\n  \r\n  用户点击登录和退出之后的业务逻辑分析：\r\n  1、用户点击登录按钮，通过路由导航钩子router.beforeEach()函数确定下一步的跳转逻辑,如下：\r\n   1.1、用户已经登录成功过，并从cookie中拿到了token值;\r\n     1.1.1、用户访问登录页面,直接定位到登录页面;\r\n     1.1.1、用户访问非登录页面,需要根据用户是否有roles信息，进行不同的业务逻辑,如下：\r\n        (1)、初始情况下,用户roles信息为空;\r\n            1.通过getUserInfo()函数,根据token拉取用户信息;并通过store将该用户roles,name,avatar信息存储于vuex;\r\n            2.通过store.dispatch('GenerateRoutes', { roles })去重新过滤和生成路由,通过router.addRoutes()合并路由表;   \r\n            3.如果在获取用户信息接口时出现错误，则调取store.dispatch('LogOut')接口,返回到login页面;\r\n          \r\n        (2)、用户已经拥有roles信息；\r\n            1.点击页面路由，通过roles权限判断 hasPermission()。如果用户有该路由权限，直接跳转对应的页面;如果没有权限，则跳转至401提示页面;\r\n  \r\n  2.用户点击退出,token已被清空\r\n    1.如果设置了白名单用户，则直接跳转到相应的页面;\r\n    2.反之,则跳转至登录页面;\r\n */"]}]}